Notes for the exam

when accessing the functions thorugh a pointer you need to use an arrow -> ratther than a dot.

to derive a class just add a : after the class name and add public(or private if desired) and the dereived class name.

you dont need to put a ; after the brackets of a class function defenition, but you can.

derefrenceing a pointer by adding * in fornt of it an assigning it a vallue will change the vallue of the objuct it's pointing to.
simillarly derefrenceing the pointer will give you the data inside the pointed object, wile leaving the pointer as it is will just give you the address value of the object you are pointing to.

to generate a random number(if needed) #include ctime and cstdlib. srand(time(0)); will result in a completly random number
rand()%15+1 will generate a random number betweet 1 and 15. rand()%15 would generate a random number between 0-14.

a const pointer will treat the variable as a const when accessed through a pointer. will not change the the ablioty to reassign the pointer to another variable, just reasigning the variable THROUGH the pointer

however a *const pointer can not change what the pointer points to. once that pointer is declared it will never point to anything else.

call by refrence. if & is used before the variable in a function definition ( void something( int & x);) it will call the variable by refrence, meaning any changes that happen to the variable inside the function will also happen to it outside the function. it works like what happens when you derefrence a pointer.

pointer increment: using ++ or -- before a pointer ( as in ++Iprt) will increment the pointer by 1 type of whatever its pointing to. example. if Iptr is of type int ++Iptr will move it foward in memory by 8 bits because and int is 8 bits long. good incrementing things when you know what you size constrains are.

pointers to pointers: you can have pointers that point to pointers that point to objects, but when declaring these pointers you need to add an * for each level of pointer. ex. int ***ptr3, **ptr2, *prt1, x=7; ptr1 = &x; ptr2=&ptr1; ptr3=&ptr2;

you can pass a pointer by refrence to a function, but in order to access it's value you must derefrence it before each call of it.

passing by *const pointer will allw you to change the value without changeing what the pointer points to.

in order to declare a pointer to a defigned function, you declare it the way you would declare a function, but the pointer name must be inside paranthases when called, and but be next to the paramater types that that paramater accepts, and it must = the function name with a & infront.
ex: void doStuff(int x); void (*ptr1)(int)=&dostuff;

A friend function is defigned in a class the same way you define a regular function, except friend is specified before the return type. It is not considered a member of the class, and i don't think it can be called by a dreived class. to invoke a freind function rather than the standard function call classObj.something() you put the class object inside the function. ex frinedName(classObj);
***pratice this


operator overloading. in order to overload an operator for a member function you defign the function as such. return type(often the class type if you want to return an anstance of that class0 the word operator, then they symbol you wannt to overload. then in parantheses you put either const objectype right, or const objectType& right, const objectType left. then continue with the function definition. scratch that. you might not need right and left. that might have just been from the example i was reading.
******thy this out yourself. i have a feeling you are going to need to pratice this one*****.
//operator overloading may not be on this one. he might mean functuon overloiading. going to study it anyway.

